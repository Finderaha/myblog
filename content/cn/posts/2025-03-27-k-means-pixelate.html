<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means 图像像素化演示</title>
</head>
<body>
    <div style="background-color: #f5f5f7; padding: 20px; border-radius: 8px; margin: 20px 0;">
  <div style="max-width: 1000px; margin: 0 auto; padding: 20px; background-color: white; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);">
    <h2 style="text-align: center; margin-bottom: 20px; color: #333;">K-Means 图像像素化交互演示</h2>
    
    <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 20px;">
      <div style="position: relative; margin-bottom: 10px;">
        <button style="background-color: #3a6ea5; color: white; padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer;">选择图片</button>
        <input type="file" id="imageUpload" accept="image/*" style="position: absolute; left: 0; top: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer;">
      </div>
      <div style="font-size: 0.9rem;">支持 JPG、PNG 等常见图片格式</div>
    </div>
    
    <div style="position: relative; margin-bottom: 30px;">
      <div style="position: relative; display: flex; justify-content: center; align-items: center; margin-bottom: 20px; width: 100%;">
        <div id="loader" style="display: none; border: 5px solid #f3f3f3; border-top: 5px solid #3a6ea5; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>
        <canvas id="originalCanvas" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);"></canvas>
        <canvas id="processedCanvas" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);"></canvas>
        <button id="playPauseButton" style="position: absolute; bottom: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; z-index: 10; font-size: 0.8rem;">暂停</button>
      </div>
      
      <div style="width: 100%; background-color: #c0d6e4; padding: 20px; border-radius: 8px; margin-top: 20px;">
        <div style="display: flex; flex-direction: column; margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span>K 值（颜色数量）:</span>
            <span id="kValue" style="font-weight: bold; color: #3a6ea5;">16</span>
          </div>
          <input type="range" id="kSlider" min="2" max="64" value="16" step="1" style="width: 100%; height: 8px; background-color: #e0e0e0; border-radius: 4px; outline: none; -webkit-appearance: none;">
        </div>
        
        <div style="margin-top: 20px; font-size: 0.9rem; text-align: center; color: #666;">
          <div>原始图像: <span id="originalColors">0</span> 种颜色 | 压缩图像: <span id="compressedColors">0</span> 种颜色</div>
          <div>压缩率: <span id="compressionRatio">0</span>%</div>
        </div>
        
        <div>
          <h3 style="color: #333;">色彩调色板</h3>
          <div id="colorPalette" style="display: flex; flex-wrap: wrap; margin-top: 10px; justify-content: center;"></div>
        </div>
      </div>
    </div>
  </div>

  <style>
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    #kSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background-color: #3a6ea5;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    #kSlider::-webkit-slider-thumb:hover {
      background-color: #245580;
      transform: scale(1.1);
    }
    
    .color-swatch {
      width: 30px;
      height: 30px;
      margin: 3px;
      border-radius: 3px;
      border: 1px solid #ddd;
    }
  </style>

  <script>
    // 全局变量
    let originalImage = null;
    let originalImageData = null;
    let kMeansWorker = null;
    let isProcessing = false;
    let isAnimationPaused = false;
    let kValue = 16;
    
    // 获取DOM元素
    const originalCanvas = document.getElementById('originalCanvas');
    const processedCanvas = document.getElementById('processedCanvas');
    const originalCtx = originalCanvas.getContext('2d');
    const processedCtx = processedCanvas.getContext('2d');
    const kSlider = document.getElementById('kSlider');
    const kValueDisplay = document.getElementById('kValue');
    const imageUpload = document.getElementById('imageUpload');
    const loader = document.getElementById('loader');
    const originalColorsDisplay = document.getElementById('originalColors');
    const compressedColorsDisplay = document.getElementById('compressedColors');
    const compressionRatioDisplay = document.getElementById('compressionRatio');
    const colorPalette = document.getElementById('colorPalette');
    const playPauseButton = document.getElementById('playPauseButton');
    
    // 初始化Web Worker
    function initWorker() {
      const workerCode = `
        // K-Means 聚类算法
        onmessage = function(e) {
          const { imageData, k, width, height } = e.data;
          
          // 提取像素数据
          const pixels = [];
          for (let i = 0; i < imageData.length; i += 4) {
            // 只处理不透明的像素
            if (imageData[i + 3] > 0) {
              pixels.push([
                imageData[i],     // R
                imageData[i + 1], // G
                imageData[i + 2]  // B
              ]);
            }
          }
          
          // 随机初始化 K 个质心
          let centroids = [];
          for (let i = 0; i < k; i++) {
            const randomIndex = Math.floor(Math.random() * pixels.length);
            centroids.push([...pixels[randomIndex]]);
          }
          
          // 运行 K-Means 算法
          const maxIterations = 10;
          let iteration = 0;
          let changed = true;
          
          // 聚类标签
          let labels = new Array(pixels.length).fill(0);
          
          while (changed && iteration < maxIterations) {
            changed = false;
            
            // 分配每个像素到最近的质心
            for (let i = 0; i < pixels.length; i++) {
              const pixel = pixels[i];
              let minDist = Infinity;
              let minIndex = 0;
              
              for (let j = 0; j < centroids.length; j++) {
                const centroid = centroids[j];
                const dist = Math.sqrt(
                  Math.pow(pixel[0] - centroid[0], 2) +
                  Math.pow(pixel[1] - centroid[1], 2) +
                  Math.pow(pixel[2] - centroid[2], 2)
                );
                
                if (dist < minDist) {
                  minDist = dist;
                  minIndex = j;
                }
              }
              
              if (labels[i] !== minIndex) {
                changed = true;
                labels[i] = minIndex;
              }
            }
            
            // 更新质心位置
            const newCentroids = Array(k).fill().map(() => [0, 0, 0]);
            const counts = Array(k).fill(0);
            
            for (let i = 0; i < pixels.length; i++) {
              const label = labels[i];
              const pixel = pixels[i];
              
              newCentroids[label][0] += pixel[0];
              newCentroids[label][1] += pixel[1];
              newCentroids[label][2] += pixel[2];
              counts[label]++;
            }
            
            for (let i = 0; i < k; i++) {
              if (counts[i] > 0) {
                newCentroids[i][0] = Math.round(newCentroids[i][0] / counts[i]);
                newCentroids[i][1] = Math.round(newCentroids[i][1] / counts[i]);
                newCentroids[i][2] = Math.round(newCentroids[i][2] / counts[i]);
              } else {
                // 如果一个簇为空，随机分配一个新的质心
                const randomIndex = Math.floor(Math.random() * pixels.length);
                newCentroids[i] = [...pixels[randomIndex]];
              }
            }
            
            centroids = newCentroids;
            iteration++;
            
            // 发送进度更新
            postMessage({
              type: 'progress',
              progress: (iteration / maxIterations) * 100
            });
          }
          
          // 创建量化后的图像数据
          const quantizedData = new Uint8ClampedArray(imageData.length);
          let pixelIndex = 0;
          
          for (let i = 0; i < imageData.length; i += 4) {
            // 保留透明通道
            if (imageData[i + 3] > 0) {
              const label = labels[pixelIndex];
              quantizedData[i] = centroids[label][0];
              quantizedData[i + 1] = centroids[label][1];
              quantizedData[i + 2] = centroids[label][2];
              quantizedData[i + 3] = imageData[i + 3];
              pixelIndex++;
            } else {
              quantizedData[i] = 0;
              quantizedData[i + 1] = 0;
              quantizedData[i + 2] = 0;
              quantizedData[i + 3] = 0;
            }
          }
          
          // 返回处理后的图像数据
          postMessage({
            type: 'result',
            quantizedData,
            centroids,
            width,
            height
          });
        };
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const workerUrl = URL.createObjectURL(blob);
      kMeansWorker = new Worker(workerUrl);
      
      kMeansWorker.onmessage = function(e) {
        const data = e.data;
        
        if (data.type === 'progress') {
          // 更新进度
          // console.log(`进度: ${data.progress.toFixed(0)}%`);
        } else if (data.type === 'result') {
          // 处理结果
          const processedImageData = new ImageData(
            data.quantizedData, 
            data.width, 
            data.height
          );
          
          // 渲染处理后的图像
          processedCanvas.width = data.width;
          processedCanvas.height = data.height;
          processedCtx.putImageData(processedImageData, 0, 0);
          
          // 更新颜色信息
          updateColorInfo(countUniqueColors(originalImageData), data.centroids);
          
          // 显示调色板
          displayColorPalette(data.centroids);
          
          // 隐藏加载动画
          loader.style.display = 'none';
          isProcessing = false;
        }
      };
    }
    
    // 计算唯一颜色数
    function countUniqueColors(imageData) {
      const colorSet = new Set();
      
      for (let i = 0; i < imageData.data.length; i += 4) {
        if (imageData.data[i + 3] > 0) { // 只考虑不透明像素
          const color = `${imageData.data[i]},${imageData.data[i + 1]},${imageData.data[i + 2]}`;
          colorSet.add(color);
        }
      }
      
      return colorSet.size;
    }
    
    // 更新颜色信息
    function updateColorInfo(originalColorCount, centroids) {
      originalColorsDisplay.textContent = originalColorCount.toLocaleString();
      compressedColorsDisplay.textContent = centroids.length.toLocaleString();
      
      const compressionRatio = ((1 - (centroids.length / originalColorCount)) * 100).toFixed(2);
      compressionRatioDisplay.textContent = compressionRatio;
    }
    
    // 显示颜色调色板
    function displayColorPalette(centroids) {
      colorPalette.innerHTML = '';
      
      centroids.forEach(centroid => {
        const [r, g, b] = centroid;
        const colorSwatch = document.createElement('div');
        colorSwatch.className = 'color-swatch';
        colorSwatch.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
        colorSwatch.title = `RGB(${r}, ${g}, ${b})`;
        colorPalette.appendChild(colorSwatch);
      });
    }
    
    // 处理图像
    function processImage() {
      if (!originalImage || isProcessing) return;
      
      isProcessing = true;
      loader.style.display = 'block';
      
      // 获取原始图像数据
      const imageData = originalCtx.getImageData(
        0, 0, 
        originalCanvas.width, 
        originalCanvas.height
      );
      
      // 将数据发送给Worker处理
      kMeansWorker.postMessage({
        imageData: imageData.data,
        k: kValue,
        width: imageData.width,
        height: imageData.height
      });
    }
    
    // 加载演示图像
    function loadDemoImage() {
      originalImage = new Image();
      originalImage.crossOrigin = 'anonymous';
      originalImage.onload = function() {
        renderOriginalImage();
        processImage();
      };
      originalImage.src = 'https://source.unsplash.com/featured/800x600/?nature,landscape';
    }
    
    // 渲染原始图像
    function renderOriginalImage() {
      // 调整canvas大小，保持图像宽高比
      const maxWidth = 600;
      const maxHeight = 400;
      let width = originalImage.width;
      let height = originalImage.height;
      
      if (width > maxWidth) {
        height = (maxWidth / width) * height;
        width = maxWidth;
      }
      
      if (height > maxHeight) {
        width = (maxHeight / height) * width;
        height = maxHeight;
      }
      
      // 设置canvas尺寸
      originalCanvas.width = width;
      originalCanvas.height = height;
      processedCanvas.width = width;
      processedCanvas.height = height;
      
      // 绘制原始图像
      originalCtx.drawImage(originalImage, 0, 0, width, height);
      
      // 存储原始图像数据
      originalImageData = originalCtx.getImageData(0, 0, width, height);
    }
    
    // 事件监听：K值滑块变化
    kSlider.addEventListener('input', function() {
      kValue = parseInt(this.value);
      kValueDisplay.textContent = kValue;
      
      // 如果未暂停，则处理图像
      if (!isAnimationPaused) {
        processImage();
      }
    });
    
    // 事件监听：图片上传
    imageUpload.addEventListener('change', function(e) {
      if (e.target.files && e.target.files[0]) {
        const reader = new FileReader();
        
        reader.onload = function(event) {
          originalImage = new Image();
          originalImage.onload = function() {
            renderOriginalImage();
            processImage();
          };
          originalImage.src = event.target.result;
        };
        
        reader.readAsDataURL(e.target.files[0]);
      }
    });
    
    // 事件监听：播放/暂停按钮
    playPauseButton.addEventListener('click', function() {
      isAnimationPaused = !isAnimationPaused;
      this.textContent = isAnimationPaused ? '播放' : '暂停';
      
      if (!isAnimationPaused) {
        processImage();
      }
    });
    
    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
      initWorker();
      loadDemoImage();
    });
  </script>
    </div>
</body>
</html>